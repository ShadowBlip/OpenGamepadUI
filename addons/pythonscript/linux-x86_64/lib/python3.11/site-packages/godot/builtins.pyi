from collections.abc import Mapping, Sequence
from enum import Enum

from .classes import GDObject


# GDany represent any type that can be send to / retreive from Godot
# (i.e. it is all the types than can be converted to a Godot Variant)
GDAny = (
    None |
    GDObject |
    bool |
    int |
    float |
    GDString |
    Vector2 |
    Vector2i |
    Rect2 |
    Rect2i |
    Vector3 |
    Vector3i |
    Transform2D |
    Vector4 |
    Vector4i |
    Plane |
    Quaternion |
    AABB |
    Basis |
    Transform3D |
    Projection |
    Color |
    StringName |
    NodePath |
    RID |
    GDCallable |
    Signal |
    GDDictionary |
    GDArray |
    PackedByteArray |
    PackedInt32Array |
    PackedInt64Array |
    PackedFloat32Array |
    PackedFloat64Array |
    PackedStringArray |
    PackedVector2Array |
    PackedVector3Array |
    PackedColorArray
)
# For convenience, we allow using Python types where Godot ones are needed.
# This allows for instance to do `my_node.do("foo")` instead of the infamous
# `my_node.do(GDString("foo"))`.
# Of course keep in mind this involves types conversion and is slower than only working
# with Godot types (for instance to speed up the previous example, `GDString("foo")`
# should be instantiated once and reused between `my_node.do(...)` calls)
IntoGDAny = GDAny | str | Mapping[IntoGDAny, IntoGDAny] | Sequence[IntoGDAny]

##############################################################################
#                              Global constants                              #
##############################################################################




##############################################################################
#                                Global enums                                #
##############################################################################


class Side(Enum):
    SIDE_LEFT: int
    SIDE_TOP: int
    SIDE_RIGHT: int
    SIDE_BOTTOM: int


class Corner(Enum):
    CORNER_TOP_LEFT: int
    CORNER_TOP_RIGHT: int
    CORNER_BOTTOM_RIGHT: int
    CORNER_BOTTOM_LEFT: int


class Orientation(Enum):
    VERTICAL: int
    HORIZONTAL: int


class ClockDirection(Enum):
    CLOCKWISE: int
    COUNTERCLOCKWISE: int


class HorizontalAlignment(Enum):
    HORIZONTAL_ALIGNMENT_LEFT: int
    HORIZONTAL_ALIGNMENT_CENTER: int
    HORIZONTAL_ALIGNMENT_RIGHT: int
    HORIZONTAL_ALIGNMENT_FILL: int


class VerticalAlignment(Enum):
    VERTICAL_ALIGNMENT_TOP: int
    VERTICAL_ALIGNMENT_CENTER: int
    VERTICAL_ALIGNMENT_BOTTOM: int
    VERTICAL_ALIGNMENT_FILL: int


class InlineAlignment(Enum):
    INLINE_ALIGNMENT_TOP_TO: int
    INLINE_ALIGNMENT_CENTER_TO: int
    INLINE_ALIGNMENT_BASELINE_TO: int
    INLINE_ALIGNMENT_BOTTOM_TO: int
    INLINE_ALIGNMENT_TO_TOP: int
    INLINE_ALIGNMENT_TO_CENTER: int
    INLINE_ALIGNMENT_TO_BASELINE: int
    INLINE_ALIGNMENT_TO_BOTTOM: int
    INLINE_ALIGNMENT_TOP: int
    INLINE_ALIGNMENT_CENTER: int
    INLINE_ALIGNMENT_BOTTOM: int
    INLINE_ALIGNMENT_IMAGE_MASK: int
    INLINE_ALIGNMENT_TEXT_MASK: int


class EulerOrder(Enum):
    EULER_ORDER_XYZ: int
    EULER_ORDER_XZY: int
    EULER_ORDER_YXZ: int
    EULER_ORDER_YZX: int
    EULER_ORDER_ZXY: int
    EULER_ORDER_ZYX: int


class Key(Enum):
    KEY_NONE: int
    KEY_SPECIAL: int
    KEY_ESCAPE: int
    KEY_TAB: int
    KEY_BACKTAB: int
    KEY_BACKSPACE: int
    KEY_ENTER: int
    KEY_KP_ENTER: int
    KEY_INSERT: int
    KEY_DELETE: int
    KEY_PAUSE: int
    KEY_PRINT: int
    KEY_SYSREQ: int
    KEY_CLEAR: int
    KEY_HOME: int
    KEY_END: int
    KEY_LEFT: int
    KEY_UP: int
    KEY_RIGHT: int
    KEY_DOWN: int
    KEY_PAGEUP: int
    KEY_PAGEDOWN: int
    KEY_SHIFT: int
    KEY_CTRL: int
    KEY_META: int
    KEY_ALT: int
    KEY_CAPSLOCK: int
    KEY_NUMLOCK: int
    KEY_SCROLLLOCK: int
    KEY_F1: int
    KEY_F2: int
    KEY_F3: int
    KEY_F4: int
    KEY_F5: int
    KEY_F6: int
    KEY_F7: int
    KEY_F8: int
    KEY_F9: int
    KEY_F10: int
    KEY_F11: int
    KEY_F12: int
    KEY_F13: int
    KEY_F14: int
    KEY_F15: int
    KEY_F16: int
    KEY_F17: int
    KEY_F18: int
    KEY_F19: int
    KEY_F20: int
    KEY_F21: int
    KEY_F22: int
    KEY_F23: int
    KEY_F24: int
    KEY_F25: int
    KEY_F26: int
    KEY_F27: int
    KEY_F28: int
    KEY_F29: int
    KEY_F30: int
    KEY_F31: int
    KEY_F32: int
    KEY_F33: int
    KEY_F34: int
    KEY_F35: int
    KEY_KP_MULTIPLY: int
    KEY_KP_DIVIDE: int
    KEY_KP_SUBTRACT: int
    KEY_KP_PERIOD: int
    KEY_KP_ADD: int
    KEY_KP_0: int
    KEY_KP_1: int
    KEY_KP_2: int
    KEY_KP_3: int
    KEY_KP_4: int
    KEY_KP_5: int
    KEY_KP_6: int
    KEY_KP_7: int
    KEY_KP_8: int
    KEY_KP_9: int
    KEY_MENU: int
    KEY_HYPER: int
    KEY_HELP: int
    KEY_BACK: int
    KEY_FORWARD: int
    KEY_STOP: int
    KEY_REFRESH: int
    KEY_VOLUMEDOWN: int
    KEY_VOLUMEMUTE: int
    KEY_VOLUMEUP: int
    KEY_MEDIAPLAY: int
    KEY_MEDIASTOP: int
    KEY_MEDIAPREVIOUS: int
    KEY_MEDIANEXT: int
    KEY_MEDIARECORD: int
    KEY_HOMEPAGE: int
    KEY_FAVORITES: int
    KEY_SEARCH: int
    KEY_STANDBY: int
    KEY_OPENURL: int
    KEY_LAUNCHMAIL: int
    KEY_LAUNCHMEDIA: int
    KEY_LAUNCH0: int
    KEY_LAUNCH1: int
    KEY_LAUNCH2: int
    KEY_LAUNCH3: int
    KEY_LAUNCH4: int
    KEY_LAUNCH5: int
    KEY_LAUNCH6: int
    KEY_LAUNCH7: int
    KEY_LAUNCH8: int
    KEY_LAUNCH9: int
    KEY_LAUNCHA: int
    KEY_LAUNCHB: int
    KEY_LAUNCHC: int
    KEY_LAUNCHD: int
    KEY_LAUNCHE: int
    KEY_LAUNCHF: int
    KEY_UNKNOWN: int
    KEY_SPACE: int
    KEY_EXCLAM: int
    KEY_QUOTEDBL: int
    KEY_NUMBERSIGN: int
    KEY_DOLLAR: int
    KEY_PERCENT: int
    KEY_AMPERSAND: int
    KEY_APOSTROPHE: int
    KEY_PARENLEFT: int
    KEY_PARENRIGHT: int
    KEY_ASTERISK: int
    KEY_PLUS: int
    KEY_COMMA: int
    KEY_MINUS: int
    KEY_PERIOD: int
    KEY_SLASH: int
    KEY_0: int
    KEY_1: int
    KEY_2: int
    KEY_3: int
    KEY_4: int
    KEY_5: int
    KEY_6: int
    KEY_7: int
    KEY_8: int
    KEY_9: int
    KEY_COLON: int
    KEY_SEMICOLON: int
    KEY_LESS: int
    KEY_EQUAL: int
    KEY_GREATER: int
    KEY_QUESTION: int
    KEY_AT: int
    KEY_A: int
    KEY_B: int
    KEY_C: int
    KEY_D: int
    KEY_E: int
    KEY_F: int
    KEY_G: int
    KEY_H: int
    KEY_I: int
    KEY_J: int
    KEY_K: int
    KEY_L: int
    KEY_M: int
    KEY_N: int
    KEY_O: int
    KEY_P: int
    KEY_Q: int
    KEY_R: int
    KEY_S: int
    KEY_T: int
    KEY_U: int
    KEY_V: int
    KEY_W: int
    KEY_X: int
    KEY_Y: int
    KEY_Z: int
    KEY_BRACKETLEFT: int
    KEY_BACKSLASH: int
    KEY_BRACKETRIGHT: int
    KEY_ASCIICIRCUM: int
    KEY_UNDERSCORE: int
    KEY_QUOTELEFT: int
    KEY_BRACELEFT: int
    KEY_BAR: int
    KEY_BRACERIGHT: int
    KEY_ASCIITILDE: int
    KEY_YEN: int
    KEY_SECTION: int
    KEY_GLOBE: int
    KEY_KEYBOARD: int
    KEY_JIS_EISU: int
    KEY_JIS_KANA: int


class KeyModifierMask(Enum):
    KEY_CODE_MASK: int
    KEY_MODIFIER_MASK: int
    KEY_MASK_CMD_OR_CTRL: int
    KEY_MASK_SHIFT: int
    KEY_MASK_ALT: int
    KEY_MASK_META: int
    KEY_MASK_CTRL: int
    KEY_MASK_KPAD: int
    KEY_MASK_GROUP_SWITCH: int


class MouseButton(Enum):
    MOUSE_BUTTON_NONE: int
    MOUSE_BUTTON_LEFT: int
    MOUSE_BUTTON_RIGHT: int
    MOUSE_BUTTON_MIDDLE: int
    MOUSE_BUTTON_WHEEL_UP: int
    MOUSE_BUTTON_WHEEL_DOWN: int
    MOUSE_BUTTON_WHEEL_LEFT: int
    MOUSE_BUTTON_WHEEL_RIGHT: int
    MOUSE_BUTTON_XBUTTON1: int
    MOUSE_BUTTON_XBUTTON2: int


class MouseButtonMask(Enum):
    MOUSE_BUTTON_MASK_LEFT: int
    MOUSE_BUTTON_MASK_RIGHT: int
    MOUSE_BUTTON_MASK_MIDDLE: int
    MOUSE_BUTTON_MASK_MB_XBUTTON1: int
    MOUSE_BUTTON_MASK_MB_XBUTTON2: int


class JoyButton(Enum):
    JOY_BUTTON_INVALID: int
    JOY_BUTTON_A: int
    JOY_BUTTON_B: int
    JOY_BUTTON_X: int
    JOY_BUTTON_Y: int
    JOY_BUTTON_BACK: int
    JOY_BUTTON_GUIDE: int
    JOY_BUTTON_START: int
    JOY_BUTTON_LEFT_STICK: int
    JOY_BUTTON_RIGHT_STICK: int
    JOY_BUTTON_LEFT_SHOULDER: int
    JOY_BUTTON_RIGHT_SHOULDER: int
    JOY_BUTTON_DPAD_UP: int
    JOY_BUTTON_DPAD_DOWN: int
    JOY_BUTTON_DPAD_LEFT: int
    JOY_BUTTON_DPAD_RIGHT: int
    JOY_BUTTON_MISC1: int
    JOY_BUTTON_PADDLE1: int
    JOY_BUTTON_PADDLE2: int
    JOY_BUTTON_PADDLE3: int
    JOY_BUTTON_PADDLE4: int
    JOY_BUTTON_TOUCHPAD: int
    JOY_BUTTON_SDL_MAX: int
    JOY_BUTTON_MAX: int


class JoyAxis(Enum):
    JOY_AXIS_INVALID: int
    JOY_AXIS_LEFT_X: int
    JOY_AXIS_LEFT_Y: int
    JOY_AXIS_RIGHT_X: int
    JOY_AXIS_RIGHT_Y: int
    JOY_AXIS_TRIGGER_LEFT: int
    JOY_AXIS_TRIGGER_RIGHT: int
    JOY_AXIS_SDL_MAX: int
    JOY_AXIS_MAX: int


class MIDIMessage(Enum):
    MIDI_MESSAGE_NONE: int
    MIDI_MESSAGE_NOTE_OFF: int
    MIDI_MESSAGE_NOTE_ON: int
    MIDI_MESSAGE_AFTERTOUCH: int
    MIDI_MESSAGE_CONTROL_CHANGE: int
    MIDI_MESSAGE_PROGRAM_CHANGE: int
    MIDI_MESSAGE_CHANNEL_PRESSURE: int
    MIDI_MESSAGE_PITCH_BEND: int
    MIDI_MESSAGE_SYSTEM_EXCLUSIVE: int
    MIDI_MESSAGE_QUARTER_FRAME: int
    MIDI_MESSAGE_SONG_POSITION_POINTER: int
    MIDI_MESSAGE_SONG_SELECT: int
    MIDI_MESSAGE_TUNE_REQUEST: int
    MIDI_MESSAGE_TIMING_CLOCK: int
    MIDI_MESSAGE_START: int
    MIDI_MESSAGE_CONTINUE: int
    MIDI_MESSAGE_STOP: int
    MIDI_MESSAGE_ACTIVE_SENSING: int
    MIDI_MESSAGE_SYSTEM_RESET: int


class Error(Enum):
    OK: int
    FAILED: int
    ERR_UNAVAILABLE: int
    ERR_UNCONFIGURED: int
    ERR_UNAUTHORIZED: int
    ERR_PARAMETER_RANGE_ERROR: int
    ERR_OUT_OF_MEMORY: int
    ERR_FILE_NOT_FOUND: int
    ERR_FILE_BAD_DRIVE: int
    ERR_FILE_BAD_PATH: int
    ERR_FILE_NO_PERMISSION: int
    ERR_FILE_ALREADY_IN_USE: int
    ERR_FILE_CANT_OPEN: int
    ERR_FILE_CANT_WRITE: int
    ERR_FILE_CANT_READ: int
    ERR_FILE_UNRECOGNIZED: int
    ERR_FILE_CORRUPT: int
    ERR_FILE_MISSING_DEPENDENCIES: int
    ERR_FILE_EOF: int
    ERR_CANT_OPEN: int
    ERR_CANT_CREATE: int
    ERR_QUERY_FAILED: int
    ERR_ALREADY_IN_USE: int
    ERR_LOCKED: int
    ERR_TIMEOUT: int
    ERR_CANT_CONNECT: int
    ERR_CANT_RESOLVE: int
    ERR_CONNECTION_ERROR: int
    ERR_CANT_ACQUIRE_RESOURCE: int
    ERR_CANT_FORK: int
    ERR_INVALID_DATA: int
    ERR_INVALID_PARAMETER: int
    ERR_ALREADY_EXISTS: int
    ERR_DOES_NOT_EXIST: int
    ERR_DATABASE_CANT_READ: int
    ERR_DATABASE_CANT_WRITE: int
    ERR_COMPILATION_FAILED: int
    ERR_METHOD_NOT_FOUND: int
    ERR_LINK_FAILED: int
    ERR_SCRIPT_FAILED: int
    ERR_CYCLIC_LINK: int
    ERR_INVALID_DECLARATION: int
    ERR_DUPLICATE_SYMBOL: int
    ERR_PARSE_ERROR: int
    ERR_BUSY: int
    ERR_SKIP: int
    ERR_HELP: int
    ERR_BUG: int
    ERR_PRINTER_ON_FIRE: int


class PropertyHint(Enum):
    PROPERTY_HINT_NONE: int
    PROPERTY_HINT_RANGE: int
    PROPERTY_HINT_ENUM: int
    PROPERTY_HINT_ENUM_SUGGESTION: int
    PROPERTY_HINT_EXP_EASING: int
    PROPERTY_HINT_LINK: int
    PROPERTY_HINT_FLAGS: int
    PROPERTY_HINT_LAYERS_2D_RENDER: int
    PROPERTY_HINT_LAYERS_2D_PHYSICS: int
    PROPERTY_HINT_LAYERS_2D_NAVIGATION: int
    PROPERTY_HINT_LAYERS_3D_RENDER: int
    PROPERTY_HINT_LAYERS_3D_PHYSICS: int
    PROPERTY_HINT_LAYERS_3D_NAVIGATION: int
    PROPERTY_HINT_LAYERS_AVOIDANCE: int
    PROPERTY_HINT_FILE: int
    PROPERTY_HINT_DIR: int
    PROPERTY_HINT_GLOBAL_FILE: int
    PROPERTY_HINT_GLOBAL_DIR: int
    PROPERTY_HINT_RESOURCE_TYPE: int
    PROPERTY_HINT_MULTILINE_TEXT: int
    PROPERTY_HINT_EXPRESSION: int
    PROPERTY_HINT_PLACEHOLDER_TEXT: int
    PROPERTY_HINT_COLOR_NO_ALPHA: int
    PROPERTY_HINT_OBJECT_ID: int
    PROPERTY_HINT_TYPE_STRING: int
    PROPERTY_HINT_NODE_PATH_TO_EDITED_NODE: int
    PROPERTY_HINT_OBJECT_TOO_BIG: int
    PROPERTY_HINT_NODE_PATH_VALID_TYPES: int
    PROPERTY_HINT_SAVE_FILE: int
    PROPERTY_HINT_GLOBAL_SAVE_FILE: int
    PROPERTY_HINT_INT_IS_OBJECTID: int
    PROPERTY_HINT_INT_IS_POINTER: int
    PROPERTY_HINT_ARRAY_TYPE: int
    PROPERTY_HINT_LOCALE_ID: int
    PROPERTY_HINT_LOCALIZABLE_STRING: int
    PROPERTY_HINT_NODE_TYPE: int
    PROPERTY_HINT_HIDE_QUATERNION_EDIT: int
    PROPERTY_HINT_PASSWORD: int
    PROPERTY_HINT_MAX: int


class PropertyUsageFlags(Enum):
    PROPERTY_USAGE_NONE: int
    PROPERTY_USAGE_STORAGE: int
    PROPERTY_USAGE_EDITOR: int
    PROPERTY_USAGE_INTERNAL: int
    PROPERTY_USAGE_CHECKABLE: int
    PROPERTY_USAGE_CHECKED: int
    PROPERTY_USAGE_GROUP: int
    PROPERTY_USAGE_CATEGORY: int
    PROPERTY_USAGE_SUBGROUP: int
    PROPERTY_USAGE_CLASS_IS_BITFIELD: int
    PROPERTY_USAGE_NO_INSTANCE_STATE: int
    PROPERTY_USAGE_RESTART_IF_CHANGED: int
    PROPERTY_USAGE_SCRIPT_VARIABLE: int
    PROPERTY_USAGE_STORE_IF_NULL: int
    PROPERTY_USAGE_UPDATE_ALL_IF_MODIFIED: int
    PROPERTY_USAGE_SCRIPT_DEFAULT_VALUE: int
    PROPERTY_USAGE_CLASS_IS_ENUM: int
    PROPERTY_USAGE_NIL_IS_VARIANT: int
    PROPERTY_USAGE_ARRAY: int
    PROPERTY_USAGE_ALWAYS_DUPLICATE: int
    PROPERTY_USAGE_NEVER_DUPLICATE: int
    PROPERTY_USAGE_HIGH_END_GFX: int
    PROPERTY_USAGE_NODE_PATH_FROM_SCENE_ROOT: int
    PROPERTY_USAGE_RESOURCE_NOT_PERSISTENT: int
    PROPERTY_USAGE_KEYING_INCREMENTS: int
    PROPERTY_USAGE_DEFERRED_SET_RESOURCE: int
    PROPERTY_USAGE_EDITOR_INSTANTIATE_OBJECT: int
    PROPERTY_USAGE_EDITOR_BASIC_SETTING: int
    PROPERTY_USAGE_READ_ONLY: int
    PROPERTY_USAGE_SECRET: int
    PROPERTY_USAGE_DEFAULT: int
    PROPERTY_USAGE_NO_EDITOR: int


class MethodFlags(Enum):
    METHOD_FLAG_NORMAL: int
    METHOD_FLAG_EDITOR: int
    METHOD_FLAG_CONST: int
    METHOD_FLAG_VIRTUAL: int
    METHOD_FLAG_VARARG: int
    METHOD_FLAG_STATIC: int
    METHOD_FLAG_OBJECT_CORE: int
    METHOD_FLAGS_DEFAULT: int


class Variant.Type(Enum):
    TYPE_NIL: int
    TYPE_BOOL: int
    TYPE_INT: int
    TYPE_FLOAT: int
    TYPE_STRING: int
    TYPE_VECTOR2: int
    TYPE_VECTOR2I: int
    TYPE_RECT2: int
    TYPE_RECT2I: int
    TYPE_VECTOR3: int
    TYPE_VECTOR3I: int
    TYPE_TRANSFORM2D: int
    TYPE_VECTOR4: int
    TYPE_VECTOR4I: int
    TYPE_PLANE: int
    TYPE_QUATERNION: int
    TYPE_AABB: int
    TYPE_BASIS: int
    TYPE_TRANSFORM3D: int
    TYPE_PROJECTION: int
    TYPE_COLOR: int
    TYPE_STRING_NAME: int
    TYPE_NODE_PATH: int
    TYPE_RID: int
    TYPE_OBJECT: int
    TYPE_CALLABLE: int
    TYPE_SIGNAL: int
    TYPE_DICTIONARY: int
    TYPE_ARRAY: int
    TYPE_PACKED_BYTE_ARRAY: int
    TYPE_PACKED_INT32_ARRAY: int
    TYPE_PACKED_INT64_ARRAY: int
    TYPE_PACKED_FLOAT32_ARRAY: int
    TYPE_PACKED_FLOAT64_ARRAY: int
    TYPE_PACKED_STRING_ARRAY: int
    TYPE_PACKED_VECTOR2_ARRAY: int
    TYPE_PACKED_VECTOR3_ARRAY: int
    TYPE_PACKED_COLOR_ARRAY: int
    TYPE_MAX: int


class Variant.Operator(Enum):
    OP_EQUAL: int
    OP_NOT_EQUAL: int
    OP_LESS: int
    OP_LESS_EQUAL: int
    OP_GREATER: int
    OP_GREATER_EQUAL: int
    OP_ADD: int
    OP_SUBTRACT: int
    OP_MULTIPLY: int
    OP_DIVIDE: int
    OP_NEGATE: int
    OP_POSITIVE: int
    OP_MODULE: int
    OP_POWER: int
    OP_SHIFT_LEFT: int
    OP_SHIFT_RIGHT: int
    OP_BIT_AND: int
    OP_BIT_OR: int
    OP_BIT_XOR: int
    OP_BIT_NEGATE: int
    OP_AND: int
    OP_OR: int
    OP_XOR: int
    OP_NOT: int
    OP_IN: int
    OP_MAX: int


##############################################################################
#                              Utility functions                             #
##############################################################################


def sin(angle_rad: float) -> float: ...
def cos(angle_rad: float) -> float: ...
def tan(angle_rad: float) -> float: ...
def sinh(x: float) -> float: ...
def cosh(x: float) -> float: ...
def tanh(x: float) -> float: ...
def asin(x: float) -> float: ...
def acos(x: float) -> float: ...
def atan(x: float) -> float: ...
def atan2(y: float, x: float) -> float: ...
def sqrt(x: float) -> float: ...
def fmod(x: float, y: float) -> float: ...
def fposmod(x: float, y: float) -> float: ...
def posmod(x: int, y: int) -> int: ...
def floor(x: IntoGDAny) -> GDAny: ...
def floorf(x: float) -> float: ...
def floori(x: float) -> int: ...
def ceil(x: IntoGDAny) -> GDAny: ...
def ceilf(x: float) -> float: ...
def ceili(x: float) -> int: ...
def round(x: IntoGDAny) -> GDAny: ...
def roundf(x: float) -> float: ...
def roundi(x: float) -> int: ...
def abs(x: IntoGDAny) -> GDAny: ...
def absf(x: float) -> float: ...
def absi(x: int) -> int: ...
def sign(x: IntoGDAny) -> GDAny: ...
def signf(x: float) -> float: ...
def signi(x: int) -> int: ...
def snapped(x: IntoGDAny, step: IntoGDAny) -> GDAny: ...
def snappedf(x: float, step: float) -> float: ...
def snappedi(x: float, step: int) -> int: ...
def pow(base: float, exp: float) -> float: ...
def log(x: float) -> float: ...
def exp(x: float) -> float: ...
def is_nan(x: float) -> bool: ...
def is_inf(x: float) -> bool: ...
def is_equal_approx(a: float, b: float) -> bool: ...
def is_zero_approx(x: float) -> bool: ...
def is_finite(x: float) -> bool: ...
def ease(x: float, curve: float) -> float: ...
def step_decimals(x: float) -> int: ...
def lerp(from_: IntoGDAny, to: IntoGDAny, weight: IntoGDAny) -> GDAny: ...
def lerpf(from_: float, to: float, weight: float) -> float: ...
def cubic_interpolate(from_: float, to: float, pre: float, post: float, weight: float) -> float: ...
def cubic_interpolate_angle(from_: float, to: float, pre: float, post: float, weight: float) -> float: ...
def cubic_interpolate_in_time(from_: float, to: float, pre: float, post: float, weight: float, to_t: float, pre_t: float, post_t: float) -> float: ...
def cubic_interpolate_angle_in_time(from_: float, to: float, pre: float, post: float, weight: float, to_t: float, pre_t: float, post_t: float) -> float: ...
def bezier_interpolate(start: float, control_1: float, control_2: float, end: float, t: float) -> float: ...
def bezier_derivative(start: float, control_1: float, control_2: float, end: float, t: float) -> float: ...
def lerp_angle(from_: float, to: float, weight: float) -> float: ...
def inverse_lerp(from_: float, to: float, weight: float) -> float: ...
def remap(value: float, istart: float, istop: float, ostart: float, ostop: float) -> float: ...
def smoothstep(from_: float, to: float, x: float) -> float: ...
def move_toward(from_: float, to: float, delta: float) -> float: ...
def deg_to_rad(deg: float) -> float: ...
def rad_to_deg(rad: float) -> float: ...
def linear_to_db(lin: float) -> float: ...
def db_to_linear(db: float) -> float: ...
def wrap(value: IntoGDAny, min: IntoGDAny, max: IntoGDAny) -> GDAny: ...
def wrapi(value: int, min: int, max: int) -> int: ...
def wrapf(value: float, min: float, max: float) -> float: ...
def max(arg1: IntoGDAny, arg2: IntoGDAny) -> GDAny: ...
def maxi(a: int, b: int) -> int: ...
def maxf(a: float, b: float) -> float: ...
def min(arg1: IntoGDAny, arg2: IntoGDAny) -> GDAny: ...
def mini(a: int, b: int) -> int: ...
def minf(a: float, b: float) -> float: ...
def clamp(value: IntoGDAny, min: IntoGDAny, max: IntoGDAny) -> GDAny: ...
def clampi(value: int, min: int, max: int) -> int: ...
def clampf(value: float, min: float, max: float) -> float: ...
def nearest_po2(value: int) -> int: ...
def pingpong(value: float, length: float) -> float: ...
def randomize() -> None: ...
def randi() -> int: ...
def randf() -> float: ...
def randi_range(from_: int, to: int) -> int: ...
def randf_range(from_: float, to: float) -> float: ...
def randfn(mean: float, deviation: float) -> float: ...
def seed(base: int) -> None: ...
def rand_from_seed(seed: int) -> PackedInt64Array: ...
def weakref(obj: IntoGDAny) -> GDAny: ...
def typeof(variable: IntoGDAny) -> int: ...
def str(arg1: IntoGDAny) -> GDString: ...
def error_string(error: int) -> GDString: ...
def print(arg1: IntoGDAny) -> None: ...
def print_rich(arg1: IntoGDAny) -> None: ...
def printerr(arg1: IntoGDAny) -> None: ...
def printt(arg1: IntoGDAny) -> None: ...
def prints(arg1: IntoGDAny) -> None: ...
def printraw(arg1: IntoGDAny) -> None: ...
def print_verbose(arg1: IntoGDAny) -> None: ...
def push_error(arg1: IntoGDAny) -> None: ...
def push_warning(arg1: IntoGDAny) -> None: ...
def var_to_str(variable: IntoGDAny) -> GDString: ...
def str_to_var(string: GDString | str) -> GDAny: ...
def var_to_bytes(variable: IntoGDAny) -> PackedByteArray: ...
def bytes_to_var(bytes: PackedByteArray) -> GDAny: ...
def var_to_bytes_with_objects(variable: IntoGDAny) -> PackedByteArray: ...
def bytes_to_var_with_objects(bytes: PackedByteArray) -> GDAny: ...
def hash(variable: IntoGDAny) -> int: ...
def instance_from_id(instance_id: int) -> GDObject: ...
def is_instance_id_valid(id: int) -> bool: ...
def is_instance_valid(instance: IntoGDAny) -> bool: ...
def rid_allocate_id() -> int: ...
def rid_from_int64(base: int) -> RID: ...
def is_same(a: IntoGDAny, b: IntoGDAny) -> bool: ...


##############################################################################
#                                  Builtins                                  #
##############################################################################


class GDString:
    def __init__(self): ...
    def __init__(self, from_: GDString | str): ...
    def __init__(self, from_: StringName | str): ...
    def __init__(self, from_: NodePath | str): ...

    # Methods
    def casecmp_to(self, to: GDString | str) -> int: ...
    def nocasecmp_to(self, to: GDString | str) -> int: ...
    def naturalcasecmp_to(self, to: GDString | str) -> int: ...
    def naturalnocasecmp_to(self, to: GDString | str) -> int: ...
    def length(self) -> int: ...
    def substr(self, from_: int, len: int = -1) -> GDString: ...
    def get_slice(self, delimiter: GDString | str, slice: int) -> GDString: ...
    def get_slicec(self, delimiter: int, slice: int) -> GDString: ...
    def get_slice_count(self, delimiter: GDString | str) -> int: ...
    def find(self, what: GDString | str, from_: int = 0) -> int: ...
    def count(self, what: GDString | str, from_: int = 0, to: int = 0) -> int: ...
    def countn(self, what: GDString | str, from_: int = 0, to: int = 0) -> int: ...
    def findn(self, what: GDString | str, from_: int = 0) -> int: ...
    def rfind(self, what: GDString | str, from_: int = -1) -> int: ...
    def rfindn(self, what: GDString | str, from_: int = -1) -> int: ...
    def match(self, expr: GDString | str) -> bool: ...
    def matchn(self, expr: GDString | str) -> bool: ...
    def begins_with(self, text: GDString | str) -> bool: ...
    def ends_with(self, text: GDString | str) -> bool: ...
    def is_subsequence_of(self, text: GDString | str) -> bool: ...
    def is_subsequence_ofn(self, text: GDString | str) -> bool: ...
    def bigrams(self) -> PackedStringArray: ...
    def similarity(self, text: GDString | str) -> float: ...
    def format(self, values: IntoGDAny, placeholder: GDString | str = "{_}") -> GDString: ...
    def replace(self, what: GDString | str, forwhat: GDString | str) -> GDString: ...
    def replacen(self, what: GDString | str, forwhat: GDString | str) -> GDString: ...
    def repeat(self, count: int) -> GDString: ...
    def insert(self, position: int, what: GDString | str) -> GDString: ...
    def erase(self, position: int, chars: int = 1) -> GDString: ...
    def capitalize(self) -> GDString: ...
    def to_camel_case(self) -> GDString: ...
    def to_pascal_case(self) -> GDString: ...
    def to_snake_case(self) -> GDString: ...
    def split(self, delimiter: GDString | str = "", allow_empty: bool = True, maxsplit: int = 0) -> PackedStringArray: ...
    def rsplit(self, delimiter: GDString | str = "", allow_empty: bool = True, maxsplit: int = 0) -> PackedStringArray: ...
    def split_floats(self, delimiter: GDString | str, allow_empty: bool = True) -> PackedFloat64Array: ...
    def join(self, parts: PackedStringArray) -> GDString: ...
    def to_upper(self) -> GDString: ...
    def to_lower(self) -> GDString: ...
    def left(self, length: int) -> GDString: ...
    def right(self, length: int) -> GDString: ...
    def strip_edges(self, left: bool = True, right: bool = True) -> GDString: ...
    def strip_escapes(self) -> GDString: ...
    def lstrip(self, chars: GDString | str) -> GDString: ...
    def rstrip(self, chars: GDString | str) -> GDString: ...
    def get_extension(self) -> GDString: ...
    def get_basename(self) -> GDString: ...
    def path_join(self, file: GDString | str) -> GDString: ...
    def unicode_at(self, at: int) -> int: ...
    def indent(self, prefix: GDString | str) -> GDString: ...
    def dedent(self) -> GDString: ...
    def hash(self) -> int: ...
    def md5_text(self) -> GDString: ...
    def sha1_text(self) -> GDString: ...
    def sha256_text(self) -> GDString: ...
    def md5_buffer(self) -> PackedByteArray: ...
    def sha1_buffer(self) -> PackedByteArray: ...
    def sha256_buffer(self) -> PackedByteArray: ...
    def is_empty(self) -> bool: ...
    def contains(self, what: GDString | str) -> bool: ...
    def is_absolute_path(self) -> bool: ...
    def is_relative_path(self) -> bool: ...
    def simplify_path(self) -> GDString: ...
    def get_base_dir(self) -> GDString: ...
    def get_file(self) -> GDString: ...
    def xml_escape(self, escape_quotes: bool = False) -> GDString: ...
    def xml_unescape(self) -> GDString: ...
    def uri_encode(self) -> GDString: ...
    def uri_decode(self) -> GDString: ...
    def c_escape(self) -> GDString: ...
    def c_unescape(self) -> GDString: ...
    def json_escape(self) -> GDString: ...
    def validate_node_name(self) -> GDString: ...
    def validate_filename(self) -> GDString: ...
    def is_valid_identifier(self) -> bool: ...
    def is_valid_int(self) -> bool: ...
    def is_valid_float(self) -> bool: ...
    def is_valid_hex_number(self, with_prefix: bool = False) -> bool: ...
    def is_valid_html_color(self) -> bool: ...
    def is_valid_ip_address(self) -> bool: ...
    def is_valid_filename(self) -> bool: ...
    def to_int(self) -> int: ...
    def to_float(self) -> float: ...
    def hex_to_int(self) -> int: ...
    def bin_to_int(self) -> int: ...
    def lpad(self, min_length: int, character: GDString | str = " ") -> GDString: ...
    def rpad(self, min_length: int, character: GDString | str = " ") -> GDString: ...
    def pad_decimals(self, digits: int) -> GDString: ...
    def pad_zeros(self, digits: int) -> GDString: ...
    def trim_prefix(self, prefix: GDString | str) -> GDString: ...
    def trim_suffix(self, suffix: GDString | str) -> GDString: ...
    def to_ascii_buffer(self) -> PackedByteArray: ...
    def to_utf8_buffer(self) -> PackedByteArray: ...
    def to_utf16_buffer(self) -> PackedByteArray: ...
    def to_utf32_buffer(self) -> PackedByteArray: ...
    def hex_decode(self) -> PackedByteArray: ...
    def to_wchar_buffer(self) -> PackedByteArray: ...
    def num_scientific(self, number: float) -> GDString: ...
    def num(self, number: float, decimals: int = -1) -> GDString: ...
    def num_int64(self, number: int, base: int = 10, capitalize_hex: bool = False) -> GDString: ...
    def num_uint64(self, number: int, base: int = 10, capitalize_hex: bool = False) -> GDString: ...
    def chr(self, char_: int) -> GDString: ...
    def humanize_size(self, size: int) -> GDString: ...


class Axis(Enum):
    AXIS_X: int
    AXIS_Y: int


class Vector2:
    def __init__(self): ...
    def __init__(self, from_: Vector2): ...
    def __init__(self, from_: Vector2i): ...
    def __init__(self, x: float, y: float): ...

    def clone(self) -> Vector2: ...

    # Members
    x: float
    y: float

    # Methods
    def angle(self) -> float: ...
    def angle_to(self, to: Vector2) -> float: ...
    def angle_to_point(self, to: Vector2) -> float: ...
    def direction_to(self, to: Vector2) -> Vector2: ...
    def distance_to(self, to: Vector2) -> float: ...
    def distance_squared_to(self, to: Vector2) -> float: ...
    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def limit_length(self, length: float = 1.0) -> Vector2: ...
    def normalized(self) -> Vector2: ...
    def is_normalized(self) -> bool: ...
    def is_equal_approx(self, to: Vector2) -> bool: ...
    def is_zero_approx(self) -> bool: ...
    def is_finite(self) -> bool: ...
    def posmod(self, mod: float) -> Vector2: ...
    def posmodv(self, modv: Vector2) -> Vector2: ...
    def project(self, b: Vector2) -> Vector2: ...
    def lerp(self, to: Vector2, weight: float) -> Vector2: ...
    def slerp(self, to: Vector2, weight: float) -> Vector2: ...
    def cubic_interpolate(self, b: Vector2, pre_a: Vector2, post_b: Vector2, weight: float) -> Vector2: ...
    def cubic_interpolate_in_time(self, b: Vector2, pre_a: Vector2, post_b: Vector2, weight: float, b_t: float, pre_a_t: float, post_b_t: float) -> Vector2: ...
    def bezier_interpolate(self, control_1: Vector2, control_2: Vector2, end: Vector2, t: float) -> Vector2: ...
    def bezier_derivative(self, control_1: Vector2, control_2: Vector2, end: Vector2, t: float) -> Vector2: ...
    def max_axis_index(self) -> int: ...
    def min_axis_index(self) -> int: ...
    def move_toward(self, to: Vector2, delta: float) -> Vector2: ...
    def rotated(self, angle: float) -> Vector2: ...
    def orthogonal(self) -> Vector2: ...
    def floor(self) -> Vector2: ...
    def ceil(self) -> Vector2: ...
    def round(self) -> Vector2: ...
    def aspect(self) -> float: ...
    def dot(self, with_: Vector2) -> float: ...
    def slide(self, n: Vector2) -> Vector2: ...
    def bounce(self, n: Vector2) -> Vector2: ...
    def reflect(self, n: Vector2) -> Vector2: ...
    def cross(self, with_: Vector2) -> float: ...
    def abs(self) -> Vector2: ...
    def sign(self) -> Vector2: ...
    def clamp(self, min: Vector2, max: Vector2) -> Vector2: ...
    def snapped(self, step: Vector2) -> Vector2: ...
    def from_angle(self, angle: float) -> Vector2: ...

    # Constants
    AXIS_X: int
    AXIS_Y: int
    ZERO: Vector2
    ONE: Vector2
    INF: Vector2
    LEFT: Vector2
    RIGHT: Vector2
    UP: Vector2
    DOWN: Vector2


class Axis(Enum):
    AXIS_X: int
    AXIS_Y: int


class Vector2i:
    def __init__(self): ...
    def __init__(self, from_: Vector2i): ...
    def __init__(self, from_: Vector2): ...
    def __init__(self, x: int, y: int): ...

    def clone(self) -> Vector2i: ...

    # Members
    x: int
    y: int

    # Methods
    def aspect(self) -> float: ...
    def max_axis_index(self) -> int: ...
    def min_axis_index(self) -> int: ...
    def length(self) -> float: ...
    def length_squared(self) -> int: ...
    def sign(self) -> Vector2i: ...
    def abs(self) -> Vector2i: ...
    def clamp(self, min: Vector2i, max: Vector2i) -> Vector2i: ...
    def snapped(self, step: Vector2i) -> Vector2i: ...

    # Constants
    AXIS_X: int
    AXIS_Y: int
    ZERO: Vector2i
    ONE: Vector2i
    LEFT: Vector2i
    RIGHT: Vector2i
    UP: Vector2i
    DOWN: Vector2i


class Rect2:
    def __init__(self): ...
    def __init__(self, from_: Rect2): ...
    def __init__(self, from_: Rect2i): ...
    def __init__(self, position: Vector2, size: Vector2): ...
    def __init__(self, x: float, y: float, width: float, height: float): ...

    def clone(self) -> Rect2: ...

    # Members
    position: Vector2
    size: Vector2
    end: Vector2

    # Methods
    def get_center(self) -> Vector2: ...
    def get_area(self) -> float: ...
    def has_area(self) -> bool: ...
    def has_point(self, point: Vector2) -> bool: ...
    def is_equal_approx(self, rect: Rect2) -> bool: ...
    def is_finite(self) -> bool: ...
    def intersects(self, b: Rect2, include_borders: bool = False) -> bool: ...
    def encloses(self, b: Rect2) -> bool: ...
    def intersection(self, b: Rect2) -> Rect2: ...
    def merge(self, b: Rect2) -> Rect2: ...
    def expand(self, to: Vector2) -> Rect2: ...
    def grow(self, amount: float) -> Rect2: ...
    def grow_side(self, side: int, amount: float) -> Rect2: ...
    def grow_individual(self, left: float, top: float, right: float, bottom: float) -> Rect2: ...
    def abs(self) -> Rect2: ...


class Rect2i:
    def __init__(self): ...
    def __init__(self, from_: Rect2i): ...
    def __init__(self, from_: Rect2): ...
    def __init__(self, position: Vector2i, size: Vector2i): ...
    def __init__(self, x: int, y: int, width: int, height: int): ...

    def clone(self) -> Rect2i: ...

    # Members
    position: Vector2i
    size: Vector2i
    end: Vector2i

    # Methods
    def get_center(self) -> Vector2i: ...
    def get_area(self) -> int: ...
    def has_area(self) -> bool: ...
    def has_point(self, point: Vector2i) -> bool: ...
    def intersects(self, b: Rect2i) -> bool: ...
    def encloses(self, b: Rect2i) -> bool: ...
    def intersection(self, b: Rect2i) -> Rect2i: ...
    def merge(self, b: Rect2i) -> Rect2i: ...
    def expand(self, to: Vector2i) -> Rect2i: ...
    def grow(self, amount: int) -> Rect2i: ...
    def grow_side(self, side: int, amount: int) -> Rect2i: ...
    def grow_individual(self, left: int, top: int, right: int, bottom: int) -> Rect2i: ...
    def abs(self) -> Rect2i: ...


class Axis(Enum):
    AXIS_X: int
    AXIS_Y: int
    AXIS_Z: int


class Vector3:
    def __init__(self): ...
    def __init__(self, from_: Vector3): ...
    def __init__(self, from_: Vector3i): ...
    def __init__(self, x: float, y: float, z: float): ...

    def clone(self) -> Vector3: ...

    # Members
    x: float
    y: float
    z: float

    # Methods
    def min_axis_index(self) -> int: ...
    def max_axis_index(self) -> int: ...
    def angle_to(self, to: Vector3) -> float: ...
    def signed_angle_to(self, to: Vector3, axis: Vector3) -> float: ...
    def direction_to(self, to: Vector3) -> Vector3: ...
    def distance_to(self, to: Vector3) -> float: ...
    def distance_squared_to(self, to: Vector3) -> float: ...
    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def limit_length(self, length: float = 1.0) -> Vector3: ...
    def normalized(self) -> Vector3: ...
    def is_normalized(self) -> bool: ...
    def is_equal_approx(self, to: Vector3) -> bool: ...
    def is_zero_approx(self) -> bool: ...
    def is_finite(self) -> bool: ...
    def inverse(self) -> Vector3: ...
    def clamp(self, min: Vector3, max: Vector3) -> Vector3: ...
    def snapped(self, step: Vector3) -> Vector3: ...
    def rotated(self, axis: Vector3, angle: float) -> Vector3: ...
    def lerp(self, to: Vector3, weight: float) -> Vector3: ...
    def slerp(self, to: Vector3, weight: float) -> Vector3: ...
    def cubic_interpolate(self, b: Vector3, pre_a: Vector3, post_b: Vector3, weight: float) -> Vector3: ...
    def cubic_interpolate_in_time(self, b: Vector3, pre_a: Vector3, post_b: Vector3, weight: float, b_t: float, pre_a_t: float, post_b_t: float) -> Vector3: ...
    def bezier_interpolate(self, control_1: Vector3, control_2: Vector3, end: Vector3, t: float) -> Vector3: ...
    def bezier_derivative(self, control_1: Vector3, control_2: Vector3, end: Vector3, t: float) -> Vector3: ...
    def move_toward(self, to: Vector3, delta: float) -> Vector3: ...
    def dot(self, with_: Vector3) -> float: ...
    def cross(self, with_: Vector3) -> Vector3: ...
    def outer(self, with_: Vector3) -> Basis: ...
    def abs(self) -> Vector3: ...
    def floor(self) -> Vector3: ...
    def ceil(self) -> Vector3: ...
    def round(self) -> Vector3: ...
    def posmod(self, mod: float) -> Vector3: ...
    def posmodv(self, modv: Vector3) -> Vector3: ...
    def project(self, b: Vector3) -> Vector3: ...
    def slide(self, n: Vector3) -> Vector3: ...
    def bounce(self, n: Vector3) -> Vector3: ...
    def reflect(self, n: Vector3) -> Vector3: ...
    def sign(self) -> Vector3: ...
    def octahedron_encode(self) -> Vector2: ...
    def octahedron_decode(self, uv: Vector2) -> Vector3: ...

    # Constants
    AXIS_X: int
    AXIS_Y: int
    AXIS_Z: int
    ZERO: Vector3
    ONE: Vector3
    INF: Vector3
    LEFT: Vector3
    RIGHT: Vector3
    UP: Vector3
    DOWN: Vector3
    FORWARD: Vector3
    BACK: Vector3
    MODEL_LEFT: Vector3
    MODEL_RIGHT: Vector3
    MODEL_TOP: Vector3
    MODEL_BOTTOM: Vector3
    MODEL_FRONT: Vector3
    MODEL_REAR: Vector3


class Axis(Enum):
    AXIS_X: int
    AXIS_Y: int
    AXIS_Z: int


class Vector3i:
    def __init__(self): ...
    def __init__(self, from_: Vector3i): ...
    def __init__(self, from_: Vector3): ...
    def __init__(self, x: int, y: int, z: int): ...

    def clone(self) -> Vector3i: ...

    # Members
    x: int
    y: int
    z: int

    # Methods
    def min_axis_index(self) -> int: ...
    def max_axis_index(self) -> int: ...
    def length(self) -> float: ...
    def length_squared(self) -> int: ...
    def sign(self) -> Vector3i: ...
    def abs(self) -> Vector3i: ...
    def clamp(self, min: Vector3i, max: Vector3i) -> Vector3i: ...
    def snapped(self, step: Vector3i) -> Vector3i: ...

    # Constants
    AXIS_X: int
    AXIS_Y: int
    AXIS_Z: int
    ZERO: Vector3i
    ONE: Vector3i
    LEFT: Vector3i
    RIGHT: Vector3i
    UP: Vector3i
    DOWN: Vector3i
    FORWARD: Vector3i
    BACK: Vector3i


class Transform2D:
    def __init__(self): ...
    def __init__(self, from_: Transform2D): ...
    def __init__(self, rotation: float, position: Vector2): ...
    def __init__(self, rotation: float, scale: Vector2, skew: float, position: Vector2): ...
    def __init__(self, x_axis: Vector2, y_axis: Vector2, origin: Vector2): ...

    def clone(self) -> Transform2D: ...

    # Members
    x: Vector2
    y: Vector2
    origin: Vector2

    # Methods
    def inverse(self) -> Transform2D: ...
    def affine_inverse(self) -> Transform2D: ...
    def get_rotation(self) -> float: ...
    def get_origin(self) -> Vector2: ...
    def get_scale(self) -> Vector2: ...
    def get_skew(self) -> float: ...
    def orthonormalized(self) -> Transform2D: ...
    def rotated(self, angle: float) -> Transform2D: ...
    def rotated_local(self, angle: float) -> Transform2D: ...
    def scaled(self, scale: Vector2) -> Transform2D: ...
    def scaled_local(self, scale: Vector2) -> Transform2D: ...
    def translated(self, offset: Vector2) -> Transform2D: ...
    def translated_local(self, offset: Vector2) -> Transform2D: ...
    def determinant(self) -> float: ...
    def basis_xform(self, v: Vector2) -> Vector2: ...
    def basis_xform_inv(self, v: Vector2) -> Vector2: ...
    def interpolate_with(self, xform: Transform2D, weight: float) -> Transform2D: ...
    def is_equal_approx(self, xform: Transform2D) -> bool: ...
    def is_finite(self) -> bool: ...
    def looking_at(self, target: Vector2 = Vector2(0, 0)) -> Transform2D: ...

    # Constants
    IDENTITY: Transform2D
    FLIP_X: Transform2D
    FLIP_Y: Transform2D


class Axis(Enum):
    AXIS_X: int
    AXIS_Y: int
    AXIS_Z: int
    AXIS_W: int


class Vector4:
    def __init__(self): ...
    def __init__(self, from_: Vector4): ...
    def __init__(self, from_: Vector4i): ...
    def __init__(self, x: float, y: float, z: float, w: float): ...

    def clone(self) -> Vector4: ...

    # Members
    x: float
    y: float
    z: float
    w: float

    # Methods
    def min_axis_index(self) -> int: ...
    def max_axis_index(self) -> int: ...
    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def abs(self) -> Vector4: ...
    def sign(self) -> Vector4: ...
    def floor(self) -> Vector4: ...
    def ceil(self) -> Vector4: ...
    def round(self) -> Vector4: ...
    def lerp(self, to: Vector4, weight: float) -> Vector4: ...
    def cubic_interpolate(self, b: Vector4, pre_a: Vector4, post_b: Vector4, weight: float) -> Vector4: ...
    def cubic_interpolate_in_time(self, b: Vector4, pre_a: Vector4, post_b: Vector4, weight: float, b_t: float, pre_a_t: float, post_b_t: float) -> Vector4: ...
    def posmod(self, mod: float) -> Vector4: ...
    def posmodv(self, modv: Vector4) -> Vector4: ...
    def snapped(self, step: Vector4) -> Vector4: ...
    def clamp(self, min: Vector4, max: Vector4) -> Vector4: ...
    def normalized(self) -> Vector4: ...
    def is_normalized(self) -> bool: ...
    def direction_to(self, to: Vector4) -> Vector4: ...
    def distance_to(self, to: Vector4) -> float: ...
    def distance_squared_to(self, to: Vector4) -> float: ...
    def dot(self, with_: Vector4) -> float: ...
    def inverse(self) -> Vector4: ...
    def is_equal_approx(self, to: Vector4) -> bool: ...
    def is_zero_approx(self) -> bool: ...
    def is_finite(self) -> bool: ...

    # Constants
    AXIS_X: int
    AXIS_Y: int
    AXIS_Z: int
    AXIS_W: int
    ZERO: Vector4
    ONE: Vector4
    INF: Vector4


class Axis(Enum):
    AXIS_X: int
    AXIS_Y: int
    AXIS_Z: int
    AXIS_W: int


class Vector4i:
    def __init__(self): ...
    def __init__(self, from_: Vector4i): ...
    def __init__(self, from_: Vector4): ...
    def __init__(self, x: int, y: int, z: int, w: int): ...

    def clone(self) -> Vector4i: ...

    # Members
    x: int
    y: int
    z: int
    w: int

    # Methods
    def min_axis_index(self) -> int: ...
    def max_axis_index(self) -> int: ...
    def length(self) -> float: ...
    def length_squared(self) -> int: ...
    def sign(self) -> Vector4i: ...
    def abs(self) -> Vector4i: ...
    def clamp(self, min: Vector4i, max: Vector4i) -> Vector4i: ...
    def snapped(self, step: Vector4i) -> Vector4i: ...

    # Constants
    AXIS_X: int
    AXIS_Y: int
    AXIS_Z: int
    AXIS_W: int
    ZERO: Vector4i
    ONE: Vector4i


class Plane:
    def __init__(self): ...
    def __init__(self, from_: Plane): ...
    def __init__(self, normal: Vector3): ...
    def __init__(self, normal: Vector3, d: float): ...
    def __init__(self, normal: Vector3, point: Vector3): ...
    def __init__(self, point1: Vector3, point2: Vector3, point3: Vector3): ...
    def __init__(self, a: float, b: float, c: float, d: float): ...

    def clone(self) -> Plane: ...

    # Members
    x: float
    y: float
    z: float
    d: float
    normal: Vector3

    # Methods
    def normalized(self) -> Plane: ...
    def get_center(self) -> Vector3: ...
    def is_equal_approx(self, to_plane: Plane) -> bool: ...
    def is_finite(self) -> bool: ...
    def is_point_over(self, point: Vector3) -> bool: ...
    def distance_to(self, point: Vector3) -> float: ...
    def has_point(self, point: Vector3, tolerance: float = 1e-05) -> bool: ...
    def project(self, point: Vector3) -> Vector3: ...
    def intersect_3(self, b: Plane, c: Plane) -> GDAny: ...
    def intersects_ray(self, from_: Vector3, dir: Vector3) -> GDAny: ...
    def intersects_segment(self, from_: Vector3, to: Vector3) -> GDAny: ...

    # Constants
    PLANE_YZ: Plane
    PLANE_XZ: Plane
    PLANE_XY: Plane


class Quaternion:
    def __init__(self): ...
    def __init__(self, from_: Quaternion): ...
    def __init__(self, from_: Basis): ...
    def __init__(self, axis: Vector3, angle: float): ...
    def __init__(self, arc_from: Vector3, arc_to: Vector3): ...
    def __init__(self, x: float, y: float, z: float, w: float): ...

    def clone(self) -> Quaternion: ...

    # Members
    x: float
    y: float
    z: float
    w: float

    # Methods
    def length(self) -> float: ...
    def length_squared(self) -> float: ...
    def normalized(self) -> Quaternion: ...
    def is_normalized(self) -> bool: ...
    def is_equal_approx(self, to: Quaternion) -> bool: ...
    def is_finite(self) -> bool: ...
    def inverse(self) -> Quaternion: ...
    def log(self) -> Quaternion: ...
    def exp(self) -> Quaternion: ...
    def angle_to(self, to: Quaternion) -> float: ...
    def dot(self, with_: Quaternion) -> float: ...
    def slerp(self, to: Quaternion, weight: float) -> Quaternion: ...
    def slerpni(self, to: Quaternion, weight: float) -> Quaternion: ...
    def spherical_cubic_interpolate(self, b: Quaternion, pre_a: Quaternion, post_b: Quaternion, weight: float) -> Quaternion: ...
    def spherical_cubic_interpolate_in_time(self, b: Quaternion, pre_a: Quaternion, post_b: Quaternion, weight: float, b_t: float, pre_a_t: float, post_b_t: float) -> Quaternion: ...
    def get_euler(self, order: int = 2) -> Vector3: ...
    def from_euler(self, euler: Vector3) -> Quaternion: ...
    def get_axis(self) -> Vector3: ...
    def get_angle(self) -> float: ...

    # Constants
    IDENTITY: Quaternion


class AABB:
    def __init__(self): ...
    def __init__(self, from_: AABB): ...
    def __init__(self, position: Vector3, size: Vector3): ...

    def clone(self) -> AABB: ...

    # Members
    position: Vector3
    size: Vector3
    end: Vector3

    # Methods
    def abs(self) -> AABB: ...
    def get_center(self) -> Vector3: ...
    def get_volume(self) -> float: ...
    def has_volume(self) -> bool: ...
    def has_surface(self) -> bool: ...
    def has_point(self, point: Vector3) -> bool: ...
    def is_equal_approx(self, aabb: AABB) -> bool: ...
    def is_finite(self) -> bool: ...
    def intersects(self, with_: AABB) -> bool: ...
    def encloses(self, with_: AABB) -> bool: ...
    def intersects_plane(self, plane: Plane) -> bool: ...
    def intersection(self, with_: AABB) -> AABB: ...
    def merge(self, with_: AABB) -> AABB: ...
    def expand(self, to_point: Vector3) -> AABB: ...
    def grow(self, by: float) -> AABB: ...
    def get_support(self, dir: Vector3) -> Vector3: ...
    def get_longest_axis(self) -> Vector3: ...
    def get_longest_axis_index(self) -> int: ...
    def get_longest_axis_size(self) -> float: ...
    def get_shortest_axis(self) -> Vector3: ...
    def get_shortest_axis_index(self) -> int: ...
    def get_shortest_axis_size(self) -> float: ...
    def get_endpoint(self, idx: int) -> Vector3: ...
    def intersects_segment(self, from_: Vector3, to: Vector3) -> GDAny: ...
    def intersects_ray(self, from_: Vector3, dir: Vector3) -> GDAny: ...


class Basis:
    def __init__(self): ...
    def __init__(self, from_: Basis): ...
    def __init__(self, from_: Quaternion): ...
    def __init__(self, axis: Vector3, angle: float): ...
    def __init__(self, x_axis: Vector3, y_axis: Vector3, z_axis: Vector3): ...

    def clone(self) -> Basis: ...

    # Members
    x: Vector3
    y: Vector3
    z: Vector3

    # Methods
    def inverse(self) -> Basis: ...
    def transposed(self) -> Basis: ...
    def orthonormalized(self) -> Basis: ...
    def determinant(self) -> float: ...
    def rotated(self, axis: Vector3, angle: float) -> Basis: ...
    def scaled(self, scale: Vector3) -> Basis: ...
    def get_scale(self) -> Vector3: ...
    def get_euler(self, order: int = 2) -> Vector3: ...
    def tdotx(self, with_: Vector3) -> float: ...
    def tdoty(self, with_: Vector3) -> float: ...
    def tdotz(self, with_: Vector3) -> float: ...
    def slerp(self, to: Basis, weight: float) -> Basis: ...
    def is_equal_approx(self, b: Basis) -> bool: ...
    def is_finite(self) -> bool: ...
    def get_rotation_quaternion(self) -> Quaternion: ...
    def looking_at(self, target: Vector3, up: Vector3 = Vector3(0, 1, 0), use_model_front: bool = False) -> Basis: ...
    def from_scale(self, scale: Vector3) -> Basis: ...
    def from_euler(self, euler: Vector3, order: int = 2) -> Basis: ...

    # Constants
    IDENTITY: Basis
    FLIP_X: Basis
    FLIP_Y: Basis
    FLIP_Z: Basis


class Transform3D:
    def __init__(self): ...
    def __init__(self, from_: Transform3D): ...
    def __init__(self, basis: Basis, origin: Vector3): ...
    def __init__(self, x_axis: Vector3, y_axis: Vector3, z_axis: Vector3, origin: Vector3): ...
    def __init__(self, from_: Projection): ...

    def clone(self) -> Transform3D: ...

    # Members
    basis: Basis
    origin: Vector3

    # Methods
    def inverse(self) -> Transform3D: ...
    def affine_inverse(self) -> Transform3D: ...
    def orthonormalized(self) -> Transform3D: ...
    def rotated(self, axis: Vector3, angle: float) -> Transform3D: ...
    def rotated_local(self, axis: Vector3, angle: float) -> Transform3D: ...
    def scaled(self, scale: Vector3) -> Transform3D: ...
    def scaled_local(self, scale: Vector3) -> Transform3D: ...
    def translated(self, offset: Vector3) -> Transform3D: ...
    def translated_local(self, offset: Vector3) -> Transform3D: ...
    def looking_at(self, target: Vector3, up: Vector3 = Vector3(0, 1, 0), use_model_front: bool = False) -> Transform3D: ...
    def interpolate_with(self, xform: Transform3D, weight: float) -> Transform3D: ...
    def is_equal_approx(self, xform: Transform3D) -> bool: ...
    def is_finite(self) -> bool: ...

    # Constants
    IDENTITY: Transform3D
    FLIP_X: Transform3D
    FLIP_Y: Transform3D
    FLIP_Z: Transform3D


class Planes(Enum):
    PLANE_NEAR: int
    PLANE_FAR: int
    PLANE_LEFT: int
    PLANE_TOP: int
    PLANE_RIGHT: int
    PLANE_BOTTOM: int


class Projection:
    def __init__(self): ...
    def __init__(self, from_: Projection): ...
    def __init__(self, from_: Transform3D): ...
    def __init__(self, x_axis: Vector4, y_axis: Vector4, z_axis: Vector4, w_axis: Vector4): ...

    def clone(self) -> Projection: ...

    # Members
    x: Vector4
    y: Vector4
    z: Vector4
    w: Vector4

    # Methods
    def create_depth_correction(self, flip_y: bool) -> Projection: ...
    def create_light_atlas_rect(self, rect: Rect2) -> Projection: ...
    def create_perspective(self, fovy: float, aspect: float, z_near: float, z_far: float, flip_fov: bool = False) -> Projection: ...
    def create_perspective_hmd(self, fovy: float, aspect: float, z_near: float, z_far: float, flip_fov: bool, eye: int, intraocular_dist: float, convergence_dist: float) -> Projection: ...
    def create_for_hmd(self, eye: int, aspect: float, intraocular_dist: float, display_width: float, display_to_lens: float, oversample: float, z_near: float, z_far: float) -> Projection: ...
    def create_orthogonal(self, left: float, right: float, bottom: float, top: float, z_near: float, z_far: float) -> Projection: ...
    def create_orthogonal_aspect(self, size: float, aspect: float, z_near: float, z_far: float, flip_fov: bool = False) -> Projection: ...
    def create_frustum(self, left: float, right: float, bottom: float, top: float, z_near: float, z_far: float) -> Projection: ...
    def create_frustum_aspect(self, size: float, aspect: float, offset: Vector2, z_near: float, z_far: float, flip_fov: bool = False) -> Projection: ...
    def create_fit_aabb(self, aabb: AABB) -> Projection: ...
    def determinant(self) -> float: ...
    def perspective_znear_adjusted(self, new_znear: float) -> Projection: ...
    def get_projection_plane(self, plane: int) -> Plane: ...
    def flipped_y(self) -> Projection: ...
    def jitter_offseted(self, offset: Vector2) -> Projection: ...
    def get_fovy(self, fovx: float, aspect: float) -> float: ...
    def get_z_far(self) -> float: ...
    def get_z_near(self) -> float: ...
    def get_aspect(self) -> float: ...
    def get_fov(self) -> float: ...
    def is_orthogonal(self) -> bool: ...
    def get_viewport_half_extents(self) -> Vector2: ...
    def get_far_plane_half_extents(self) -> Vector2: ...
    def inverse(self) -> Projection: ...
    def get_pixels_per_meter(self, for_pixel_width: int) -> int: ...
    def get_lod_multiplier(self) -> float: ...

    # Constants
    PLANE_NEAR: int
    PLANE_FAR: int
    PLANE_LEFT: int
    PLANE_TOP: int
    PLANE_RIGHT: int
    PLANE_BOTTOM: int
    IDENTITY: Projection
    ZERO: Projection


class Color:
    def __init__(self): ...
    def __init__(self, from_: Color): ...
    def __init__(self, from_: Color, alpha: float): ...
    def __init__(self, r: float, g: float, b: float): ...
    def __init__(self, r: float, g: float, b: float, a: float): ...
    def __init__(self, code: GDString | str): ...
    def __init__(self, code: GDString | str, alpha: float): ...

    def clone(self) -> Color: ...

    # Members
    r: float
    g: float
    b: float
    a: float
    r8: int
    g8: int
    b8: int
    a8: int
    h: float
    s: float
    v: float

    # Methods
    def to_argb32(self) -> int: ...
    def to_abgr32(self) -> int: ...
    def to_rgba32(self) -> int: ...
    def to_argb64(self) -> int: ...
    def to_abgr64(self) -> int: ...
    def to_rgba64(self) -> int: ...
    def to_html(self, with_alpha: bool = True) -> GDString: ...
    def clamp(self, min: Color = Color(0, 0, 0, 0), max: Color = Color(1, 1, 1, 1)) -> Color: ...
    def inverted(self) -> Color: ...
    def lerp(self, to: Color, weight: float) -> Color: ...
    def lightened(self, amount: float) -> Color: ...
    def darkened(self, amount: float) -> Color: ...
    def blend(self, over: Color) -> Color: ...
    def get_luminance(self) -> float: ...
    def srgb_to_linear(self) -> Color: ...
    def linear_to_srgb(self) -> Color: ...
    def is_equal_approx(self, to: Color) -> bool: ...
    def hex(self, hex: int) -> Color: ...
    def hex64(self, hex: int) -> Color: ...
    def html(self, rgba: GDString | str) -> Color: ...
    def html_is_valid(self, color: GDString | str) -> bool: ...
    def from_string(self, str: GDString | str, default: Color) -> Color: ...
    def from_hsv(self, h: float, s: float, v: float, alpha: float = 1.0) -> Color: ...
    def from_ok_hsl(self, h: float, s: float, l: float, alpha: float = 1.0) -> Color: ...
    def from_rgbe9995(self, rgbe: int) -> Color: ...

    # Constants
    ALICE_BLUE: Color
    ANTIQUE_WHITE: Color
    AQUA: Color
    AQUAMARINE: Color
    AZURE: Color
    BEIGE: Color
    BISQUE: Color
    BLACK: Color
    BLANCHED_ALMOND: Color
    BLUE: Color
    BLUE_VIOLET: Color
    BROWN: Color
    BURLYWOOD: Color
    CADET_BLUE: Color
    CHARTREUSE: Color
    CHOCOLATE: Color
    CORAL: Color
    CORNFLOWER_BLUE: Color
    CORNSILK: Color
    CRIMSON: Color
    CYAN: Color
    DARK_BLUE: Color
    DARK_CYAN: Color
    DARK_GOLDENROD: Color
    DARK_GRAY: Color
    DARK_GREEN: Color
    DARK_KHAKI: Color
    DARK_MAGENTA: Color
    DARK_OLIVE_GREEN: Color
    DARK_ORANGE: Color
    DARK_ORCHID: Color
    DARK_RED: Color
    DARK_SALMON: Color
    DARK_SEA_GREEN: Color
    DARK_SLATE_BLUE: Color
    DARK_SLATE_GRAY: Color
    DARK_TURQUOISE: Color
    DARK_VIOLET: Color
    DEEP_PINK: Color
    DEEP_SKY_BLUE: Color
    DIM_GRAY: Color
    DODGER_BLUE: Color
    FIREBRICK: Color
    FLORAL_WHITE: Color
    FOREST_GREEN: Color
    FUCHSIA: Color
    GAINSBORO: Color
    GHOST_WHITE: Color
    GOLD: Color
    GOLDENROD: Color
    GRAY: Color
    GREEN: Color
    GREEN_YELLOW: Color
    HONEYDEW: Color
    HOT_PINK: Color
    INDIAN_RED: Color
    INDIGO: Color
    IVORY: Color
    KHAKI: Color
    LAVENDER: Color
    LAVENDER_BLUSH: Color
    LAWN_GREEN: Color
    LEMON_CHIFFON: Color
    LIGHT_BLUE: Color
    LIGHT_CORAL: Color
    LIGHT_CYAN: Color
    LIGHT_GOLDENROD: Color
    LIGHT_GRAY: Color
    LIGHT_GREEN: Color
    LIGHT_PINK: Color
    LIGHT_SALMON: Color
    LIGHT_SEA_GREEN: Color
    LIGHT_SKY_BLUE: Color
    LIGHT_SLATE_GRAY: Color
    LIGHT_STEEL_BLUE: Color
    LIGHT_YELLOW: Color
    LIME: Color
    LIME_GREEN: Color
    LINEN: Color
    MAGENTA: Color
    MAROON: Color
    MEDIUM_AQUAMARINE: Color
    MEDIUM_BLUE: Color
    MEDIUM_ORCHID: Color
    MEDIUM_PURPLE: Color
    MEDIUM_SEA_GREEN: Color
    MEDIUM_SLATE_BLUE: Color
    MEDIUM_SPRING_GREEN: Color
    MEDIUM_TURQUOISE: Color
    MEDIUM_VIOLET_RED: Color
    MIDNIGHT_BLUE: Color
    MINT_CREAM: Color
    MISTY_ROSE: Color
    MOCCASIN: Color
    NAVAJO_WHITE: Color
    NAVY_BLUE: Color
    OLD_LACE: Color
    OLIVE: Color
    OLIVE_DRAB: Color
    ORANGE: Color
    ORANGE_RED: Color
    ORCHID: Color
    PALE_GOLDENROD: Color
    PALE_GREEN: Color
    PALE_TURQUOISE: Color
    PALE_VIOLET_RED: Color
    PAPAYA_WHIP: Color
    PEACH_PUFF: Color
    PERU: Color
    PINK: Color
    PLUM: Color
    POWDER_BLUE: Color
    PURPLE: Color
    REBECCA_PURPLE: Color
    RED: Color
    ROSY_BROWN: Color
    ROYAL_BLUE: Color
    SADDLE_BROWN: Color
    SALMON: Color
    SANDY_BROWN: Color
    SEA_GREEN: Color
    SEASHELL: Color
    SIENNA: Color
    SILVER: Color
    SKY_BLUE: Color
    SLATE_BLUE: Color
    SLATE_GRAY: Color
    SNOW: Color
    SPRING_GREEN: Color
    STEEL_BLUE: Color
    TAN: Color
    TEAL: Color
    THISTLE: Color
    TOMATO: Color
    TRANSPARENT: Color
    TURQUOISE: Color
    VIOLET: Color
    WEB_GRAY: Color
    WEB_GREEN: Color
    WEB_MAROON: Color
    WEB_PURPLE: Color
    WHEAT: Color
    WHITE: Color
    WHITE_SMOKE: Color
    YELLOW: Color
    YELLOW_GREEN: Color


class StringName:
    def __init__(self): ...
    def __init__(self, from_: StringName | str): ...
    def __init__(self, from_: GDString | str): ...

    # Methods
    def casecmp_to(self, to: GDString | str) -> int: ...
    def nocasecmp_to(self, to: GDString | str) -> int: ...
    def naturalcasecmp_to(self, to: GDString | str) -> int: ...
    def naturalnocasecmp_to(self, to: GDString | str) -> int: ...
    def length(self) -> int: ...
    def substr(self, from_: int, len: int = -1) -> GDString: ...
    def get_slice(self, delimiter: GDString | str, slice: int) -> GDString: ...
    def get_slicec(self, delimiter: int, slice: int) -> GDString: ...
    def get_slice_count(self, delimiter: GDString | str) -> int: ...
    def find(self, what: GDString | str, from_: int = 0) -> int: ...
    def count(self, what: GDString | str, from_: int = 0, to: int = 0) -> int: ...
    def countn(self, what: GDString | str, from_: int = 0, to: int = 0) -> int: ...
    def findn(self, what: GDString | str, from_: int = 0) -> int: ...
    def rfind(self, what: GDString | str, from_: int = -1) -> int: ...
    def rfindn(self, what: GDString | str, from_: int = -1) -> int: ...
    def match(self, expr: GDString | str) -> bool: ...
    def matchn(self, expr: GDString | str) -> bool: ...
    def begins_with(self, text: GDString | str) -> bool: ...
    def ends_with(self, text: GDString | str) -> bool: ...
    def is_subsequence_of(self, text: GDString | str) -> bool: ...
    def is_subsequence_ofn(self, text: GDString | str) -> bool: ...
    def bigrams(self) -> PackedStringArray: ...
    def similarity(self, text: GDString | str) -> float: ...
    def format(self, values: IntoGDAny, placeholder: GDString | str = "{_}") -> GDString: ...
    def replace(self, what: GDString | str, forwhat: GDString | str) -> GDString: ...
    def replacen(self, what: GDString | str, forwhat: GDString | str) -> GDString: ...
    def repeat(self, count: int) -> GDString: ...
    def insert(self, position: int, what: GDString | str) -> GDString: ...
    def erase(self, position: int, chars: int = 1) -> GDString: ...
    def capitalize(self) -> GDString: ...
    def to_camel_case(self) -> GDString: ...
    def to_pascal_case(self) -> GDString: ...
    def to_snake_case(self) -> GDString: ...
    def split(self, delimiter: GDString | str = "", allow_empty: bool = True, maxsplit: int = 0) -> PackedStringArray: ...
    def rsplit(self, delimiter: GDString | str = "", allow_empty: bool = True, maxsplit: int = 0) -> PackedStringArray: ...
    def split_floats(self, delimiter: GDString | str, allow_empty: bool = True) -> PackedFloat64Array: ...
    def join(self, parts: PackedStringArray) -> GDString: ...
    def to_upper(self) -> GDString: ...
    def to_lower(self) -> GDString: ...
    def left(self, length: int) -> GDString: ...
    def right(self, length: int) -> GDString: ...
    def strip_edges(self, left: bool = True, right: bool = True) -> GDString: ...
    def strip_escapes(self) -> GDString: ...
    def lstrip(self, chars: GDString | str) -> GDString: ...
    def rstrip(self, chars: GDString | str) -> GDString: ...
    def get_extension(self) -> GDString: ...
    def get_basename(self) -> GDString: ...
    def path_join(self, file: GDString | str) -> GDString: ...
    def unicode_at(self, at: int) -> int: ...
    def indent(self, prefix: GDString | str) -> GDString: ...
    def dedent(self) -> GDString: ...
    def md5_text(self) -> GDString: ...
    def sha1_text(self) -> GDString: ...
    def sha256_text(self) -> GDString: ...
    def md5_buffer(self) -> PackedByteArray: ...
    def sha1_buffer(self) -> PackedByteArray: ...
    def sha256_buffer(self) -> PackedByteArray: ...
    def is_empty(self) -> bool: ...
    def contains(self, what: GDString | str) -> bool: ...
    def is_absolute_path(self) -> bool: ...
    def is_relative_path(self) -> bool: ...
    def simplify_path(self) -> GDString: ...
    def get_base_dir(self) -> GDString: ...
    def get_file(self) -> GDString: ...
    def xml_escape(self, escape_quotes: bool = False) -> GDString: ...
    def xml_unescape(self) -> GDString: ...
    def uri_encode(self) -> GDString: ...
    def uri_decode(self) -> GDString: ...
    def c_escape(self) -> GDString: ...
    def c_unescape(self) -> GDString: ...
    def json_escape(self) -> GDString: ...
    def validate_node_name(self) -> GDString: ...
    def validate_filename(self) -> GDString: ...
    def is_valid_identifier(self) -> bool: ...
    def is_valid_int(self) -> bool: ...
    def is_valid_float(self) -> bool: ...
    def is_valid_hex_number(self, with_prefix: bool = False) -> bool: ...
    def is_valid_html_color(self) -> bool: ...
    def is_valid_ip_address(self) -> bool: ...
    def is_valid_filename(self) -> bool: ...
    def to_int(self) -> int: ...
    def to_float(self) -> float: ...
    def hex_to_int(self) -> int: ...
    def bin_to_int(self) -> int: ...
    def lpad(self, min_length: int, character: GDString | str = " ") -> GDString: ...
    def rpad(self, min_length: int, character: GDString | str = " ") -> GDString: ...
    def pad_decimals(self, digits: int) -> GDString: ...
    def pad_zeros(self, digits: int) -> GDString: ...
    def trim_prefix(self, prefix: GDString | str) -> GDString: ...
    def trim_suffix(self, suffix: GDString | str) -> GDString: ...
    def to_ascii_buffer(self) -> PackedByteArray: ...
    def to_utf8_buffer(self) -> PackedByteArray: ...
    def to_utf16_buffer(self) -> PackedByteArray: ...
    def to_utf32_buffer(self) -> PackedByteArray: ...
    def hex_decode(self) -> PackedByteArray: ...
    def to_wchar_buffer(self) -> PackedByteArray: ...
    def hash(self) -> int: ...


class NodePath:
    def __init__(self): ...
    def __init__(self, from_: NodePath | str): ...
    def __init__(self, from_: GDString | str): ...

    # Methods
    def is_absolute(self) -> bool: ...
    def get_name_count(self) -> int: ...
    def get_name(self, idx: int) -> StringName: ...
    def get_subname_count(self) -> int: ...
    def hash(self) -> int: ...
    def get_subname(self, idx: int) -> StringName: ...
    def get_concatenated_names(self) -> StringName: ...
    def get_concatenated_subnames(self) -> StringName: ...
    def get_as_property_path(self) -> NodePath: ...
    def is_empty(self) -> bool: ...


class RID:
    def __init__(self): ...
    def __init__(self, from_: RID): ...

    # Methods
    def is_valid(self) -> bool: ...
    def get_id(self) -> int: ...


class GDCallable:
    def __init__(self): ...
    def __init__(self, from_: GDCallable): ...
    def __init__(self, object: GDObject, method: StringName | str): ...

    # Methods
    def callv(self, arguments: GDArray) -> GDAny: ...
    def is_null(self) -> bool: ...
    def is_custom(self) -> bool: ...
    def is_standard(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def get_object(self) -> GDObject: ...
    def get_object_id(self) -> int: ...
    def get_method(self) -> StringName: ...
    def get_bound_arguments_count(self) -> int: ...
    def get_bound_arguments(self) -> GDArray: ...
    def hash(self) -> int: ...
    def bindv(self, arguments: GDArray) -> GDCallable: ...
    def unbind(self, argcount: int) -> GDCallable: ...
    def call(self) -> GDAny: ...
    def call_deferred(self) -> None: ...
    def rpc(self) -> None: ...
    def rpc_id(self, peer_id: int) -> None: ...
    def bind(self) -> GDCallable: ...


class Signal:
    def __init__(self): ...
    def __init__(self, from_: Signal): ...
    def __init__(self, object: GDObject, signal: StringName | str): ...

    # Methods
    def is_null(self) -> bool: ...
    def get_object(self) -> GDObject: ...
    def get_object_id(self) -> int: ...
    def get_name(self) -> StringName: ...
    def connect(self, callable: GDCallable, flags: int = 0) -> int: ...
    def disconnect(self, callable: GDCallable) -> None: ...
    def is_connected(self, callable: GDCallable) -> bool: ...
    def get_connections(self) -> GDArray: ...
    def emit(self) -> None: ...


class GDDictionary:
    def __init__(self): ...
    def __init__(self, from_: GDDictionary | Mapping[IntoGDAny, IntoGDAny]): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def clear(self) -> None: ...
    def merge(self, dictionary: GDDictionary | Mapping[IntoGDAny, IntoGDAny], overwrite: bool = False) -> None: ...
    def has(self, key: IntoGDAny) -> bool: ...
    def has_all(self, keys: GDArray) -> bool: ...
    def find_key(self, value: IntoGDAny) -> GDAny: ...
    def erase(self, key: IntoGDAny) -> bool: ...
    def hash(self) -> int: ...
    def keys(self) -> GDArray: ...
    def values(self) -> GDArray: ...
    def duplicate(self, deep: bool = False) -> GDDictionary: ...
    def get(self, key: IntoGDAny, default: IntoGDAny = None) -> GDAny: ...
    def make_read_only(self) -> None: ...
    def is_read_only(self) -> bool: ...


class GDArray:
    def __init__(self): ...
    def __init__(self, from_: GDArray): ...
    def __init__(self, base: GDArray, type: int, class_name: StringName | str, script: IntoGDAny): ...
    def __init__(self, from_: PackedByteArray): ...
    def __init__(self, from_: PackedInt32Array): ...
    def __init__(self, from_: PackedInt64Array): ...
    def __init__(self, from_: PackedFloat32Array): ...
    def __init__(self, from_: PackedFloat64Array): ...
    def __init__(self, from_: PackedStringArray): ...
    def __init__(self, from_: PackedVector2Array): ...
    def __init__(self, from_: PackedVector3Array): ...
    def __init__(self, from_: PackedColorArray): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def clear(self) -> None: ...
    def hash(self) -> int: ...
    def assign(self, array: GDArray) -> None: ...
    def push_back(self, value: IntoGDAny) -> None: ...
    def push_front(self, value: IntoGDAny) -> None: ...
    def append(self, value: IntoGDAny) -> None: ...
    def append_array(self, array: GDArray) -> None: ...
    def resize(self, size: int) -> int: ...
    def insert(self, position: int, value: IntoGDAny) -> int: ...
    def remove_at(self, position: int) -> None: ...
    def fill(self, value: IntoGDAny) -> None: ...
    def erase(self, value: IntoGDAny) -> None: ...
    def front(self) -> GDAny: ...
    def back(self) -> GDAny: ...
    def pick_random(self) -> GDAny: ...
    def find(self, what: IntoGDAny, from_: int = 0) -> int: ...
    def rfind(self, what: IntoGDAny, from_: int = -1) -> int: ...
    def count(self, value: IntoGDAny) -> int: ...
    def has(self, value: IntoGDAny) -> bool: ...
    def pop_back(self) -> GDAny: ...
    def pop_front(self) -> GDAny: ...
    def pop_at(self, position: int) -> GDAny: ...
    def sort(self) -> None: ...
    def sort_custom(self, func: GDCallable) -> None: ...
    def shuffle(self) -> None: ...
    def bsearch(self, value: IntoGDAny, before: bool = True) -> int: ...
    def bsearch_custom(self, value: IntoGDAny, func: GDCallable, before: bool = True) -> int: ...
    def reverse(self) -> None: ...
    def duplicate(self, deep: bool = False) -> GDArray: ...
    def slice(self, begin: int, end: int = 2147483647, step: int = 1, deep: bool = False) -> GDArray: ...
    def filter(self, method: GDCallable) -> GDArray: ...
    def map(self, method: GDCallable) -> GDArray: ...
    def reduce(self, method: GDCallable, accum: IntoGDAny = None) -> GDAny: ...
    def any(self, method: GDCallable) -> bool: ...
    def all(self, method: GDCallable) -> bool: ...
    def max(self) -> GDAny: ...
    def min(self) -> GDAny: ...
    def is_typed(self) -> bool: ...
    def is_same_typed(self, array: GDArray) -> bool: ...
    def get_typed_builtin(self) -> int: ...
    def get_typed_class_name(self) -> StringName: ...
    def get_typed_script(self) -> GDAny: ...
    def make_read_only(self) -> None: ...
    def is_read_only(self) -> bool: ...


class PackedByteArray:
    def __init__(self): ...
    def __init__(self, from_: PackedByteArray): ...
    def __init__(self, from_: GDArray): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def set(self, index: int, value: int) -> None: ...
    def push_back(self, value: int) -> bool: ...
    def append(self, value: int) -> bool: ...
    def append_array(self, array: PackedByteArray) -> None: ...
    def remove_at(self, index: int) -> None: ...
    def insert(self, at_index: int, value: int) -> int: ...
    def fill(self, value: int) -> None: ...
    def resize(self, new_size: int) -> int: ...
    def clear(self) -> None: ...
    def has(self, value: int) -> bool: ...
    def reverse(self) -> None: ...
    def slice(self, begin: int, end: int = 2147483647) -> PackedByteArray: ...
    def sort(self) -> None: ...
    def bsearch(self, value: int, before: bool = True) -> int: ...
    def duplicate(self) -> PackedByteArray: ...
    def find(self, value: int, from_: int = 0) -> int: ...
    def rfind(self, value: int, from_: int = -1) -> int: ...
    def count(self, value: int) -> int: ...
    def get_string_from_ascii(self) -> GDString: ...
    def get_string_from_utf8(self) -> GDString: ...
    def get_string_from_utf16(self) -> GDString: ...
    def get_string_from_utf32(self) -> GDString: ...
    def get_string_from_wchar(self) -> GDString: ...
    def hex_encode(self) -> GDString: ...
    def compress(self, compression_mode: int = 0) -> PackedByteArray: ...
    def decompress(self, buffer_size: int, compression_mode: int = 0) -> PackedByteArray: ...
    def decompress_dynamic(self, max_output_size: int, compression_mode: int = 0) -> PackedByteArray: ...
    def decode_u8(self, byte_offset: int) -> int: ...
    def decode_s8(self, byte_offset: int) -> int: ...
    def decode_u16(self, byte_offset: int) -> int: ...
    def decode_s16(self, byte_offset: int) -> int: ...
    def decode_u32(self, byte_offset: int) -> int: ...
    def decode_s32(self, byte_offset: int) -> int: ...
    def decode_u64(self, byte_offset: int) -> int: ...
    def decode_s64(self, byte_offset: int) -> int: ...
    def decode_half(self, byte_offset: int) -> float: ...
    def decode_float(self, byte_offset: int) -> float: ...
    def decode_double(self, byte_offset: int) -> float: ...
    def has_encoded_var(self, byte_offset: int, allow_objects: bool = False) -> bool: ...
    def decode_var(self, byte_offset: int, allow_objects: bool = False) -> GDAny: ...
    def decode_var_size(self, byte_offset: int, allow_objects: bool = False) -> int: ...
    def to_int32_array(self) -> PackedInt32Array: ...
    def to_int64_array(self) -> PackedInt64Array: ...
    def to_float32_array(self) -> PackedFloat32Array: ...
    def to_float64_array(self) -> PackedFloat64Array: ...
    def encode_u8(self, byte_offset: int, value: int) -> None: ...
    def encode_s8(self, byte_offset: int, value: int) -> None: ...
    def encode_u16(self, byte_offset: int, value: int) -> None: ...
    def encode_s16(self, byte_offset: int, value: int) -> None: ...
    def encode_u32(self, byte_offset: int, value: int) -> None: ...
    def encode_s32(self, byte_offset: int, value: int) -> None: ...
    def encode_u64(self, byte_offset: int, value: int) -> None: ...
    def encode_s64(self, byte_offset: int, value: int) -> None: ...
    def encode_half(self, byte_offset: int, value: float) -> None: ...
    def encode_float(self, byte_offset: int, value: float) -> None: ...
    def encode_double(self, byte_offset: int, value: float) -> None: ...
    def encode_var(self, byte_offset: int, value: IntoGDAny, allow_objects: bool = False) -> int: ...


class PackedInt32Array:
    def __init__(self): ...
    def __init__(self, from_: PackedInt32Array): ...
    def __init__(self, from_: GDArray): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def set(self, index: int, value: int) -> None: ...
    def push_back(self, value: int) -> bool: ...
    def append(self, value: int) -> bool: ...
    def append_array(self, array: PackedInt32Array) -> None: ...
    def remove_at(self, index: int) -> None: ...
    def insert(self, at_index: int, value: int) -> int: ...
    def fill(self, value: int) -> None: ...
    def resize(self, new_size: int) -> int: ...
    def clear(self) -> None: ...
    def has(self, value: int) -> bool: ...
    def reverse(self) -> None: ...
    def slice(self, begin: int, end: int = 2147483647) -> PackedInt32Array: ...
    def to_byte_array(self) -> PackedByteArray: ...
    def sort(self) -> None: ...
    def bsearch(self, value: int, before: bool = True) -> int: ...
    def duplicate(self) -> PackedInt32Array: ...
    def find(self, value: int, from_: int = 0) -> int: ...
    def rfind(self, value: int, from_: int = -1) -> int: ...
    def count(self, value: int) -> int: ...


class PackedInt64Array:
    def __init__(self): ...
    def __init__(self, from_: PackedInt64Array): ...
    def __init__(self, from_: GDArray): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def set(self, index: int, value: int) -> None: ...
    def push_back(self, value: int) -> bool: ...
    def append(self, value: int) -> bool: ...
    def append_array(self, array: PackedInt64Array) -> None: ...
    def remove_at(self, index: int) -> None: ...
    def insert(self, at_index: int, value: int) -> int: ...
    def fill(self, value: int) -> None: ...
    def resize(self, new_size: int) -> int: ...
    def clear(self) -> None: ...
    def has(self, value: int) -> bool: ...
    def reverse(self) -> None: ...
    def slice(self, begin: int, end: int = 2147483647) -> PackedInt64Array: ...
    def to_byte_array(self) -> PackedByteArray: ...
    def sort(self) -> None: ...
    def bsearch(self, value: int, before: bool = True) -> int: ...
    def duplicate(self) -> PackedInt64Array: ...
    def find(self, value: int, from_: int = 0) -> int: ...
    def rfind(self, value: int, from_: int = -1) -> int: ...
    def count(self, value: int) -> int: ...


class PackedFloat32Array:
    def __init__(self): ...
    def __init__(self, from_: PackedFloat32Array): ...
    def __init__(self, from_: GDArray): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def set(self, index: int, value: float) -> None: ...
    def push_back(self, value: float) -> bool: ...
    def append(self, value: float) -> bool: ...
    def append_array(self, array: PackedFloat32Array) -> None: ...
    def remove_at(self, index: int) -> None: ...
    def insert(self, at_index: int, value: float) -> int: ...
    def fill(self, value: float) -> None: ...
    def resize(self, new_size: int) -> int: ...
    def clear(self) -> None: ...
    def has(self, value: float) -> bool: ...
    def reverse(self) -> None: ...
    def slice(self, begin: int, end: int = 2147483647) -> PackedFloat32Array: ...
    def to_byte_array(self) -> PackedByteArray: ...
    def sort(self) -> None: ...
    def bsearch(self, value: float, before: bool = True) -> int: ...
    def duplicate(self) -> PackedFloat32Array: ...
    def find(self, value: float, from_: int = 0) -> int: ...
    def rfind(self, value: float, from_: int = -1) -> int: ...
    def count(self, value: float) -> int: ...


class PackedFloat64Array:
    def __init__(self): ...
    def __init__(self, from_: PackedFloat64Array): ...
    def __init__(self, from_: GDArray): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def set(self, index: int, value: float) -> None: ...
    def push_back(self, value: float) -> bool: ...
    def append(self, value: float) -> bool: ...
    def append_array(self, array: PackedFloat64Array) -> None: ...
    def remove_at(self, index: int) -> None: ...
    def insert(self, at_index: int, value: float) -> int: ...
    def fill(self, value: float) -> None: ...
    def resize(self, new_size: int) -> int: ...
    def clear(self) -> None: ...
    def has(self, value: float) -> bool: ...
    def reverse(self) -> None: ...
    def slice(self, begin: int, end: int = 2147483647) -> PackedFloat64Array: ...
    def to_byte_array(self) -> PackedByteArray: ...
    def sort(self) -> None: ...
    def bsearch(self, value: float, before: bool = True) -> int: ...
    def duplicate(self) -> PackedFloat64Array: ...
    def find(self, value: float, from_: int = 0) -> int: ...
    def rfind(self, value: float, from_: int = -1) -> int: ...
    def count(self, value: float) -> int: ...


class PackedStringArray:
    def __init__(self): ...
    def __init__(self, from_: PackedStringArray): ...
    def __init__(self, from_: GDArray): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def set(self, index: int, value: GDString | str) -> None: ...
    def push_back(self, value: GDString | str) -> bool: ...
    def append(self, value: GDString | str) -> bool: ...
    def append_array(self, array: PackedStringArray) -> None: ...
    def remove_at(self, index: int) -> None: ...
    def insert(self, at_index: int, value: GDString | str) -> int: ...
    def fill(self, value: GDString | str) -> None: ...
    def resize(self, new_size: int) -> int: ...
    def clear(self) -> None: ...
    def has(self, value: GDString | str) -> bool: ...
    def reverse(self) -> None: ...
    def slice(self, begin: int, end: int = 2147483647) -> PackedStringArray: ...
    def to_byte_array(self) -> PackedByteArray: ...
    def sort(self) -> None: ...
    def bsearch(self, value: GDString | str, before: bool = True) -> int: ...
    def duplicate(self) -> PackedStringArray: ...
    def find(self, value: GDString | str, from_: int = 0) -> int: ...
    def rfind(self, value: GDString | str, from_: int = -1) -> int: ...
    def count(self, value: GDString | str) -> int: ...


class PackedVector2Array:
    def __init__(self): ...
    def __init__(self, from_: PackedVector2Array): ...
    def __init__(self, from_: GDArray): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def set(self, index: int, value: Vector2) -> None: ...
    def push_back(self, value: Vector2) -> bool: ...
    def append(self, value: Vector2) -> bool: ...
    def append_array(self, array: PackedVector2Array) -> None: ...
    def remove_at(self, index: int) -> None: ...
    def insert(self, at_index: int, value: Vector2) -> int: ...
    def fill(self, value: Vector2) -> None: ...
    def resize(self, new_size: int) -> int: ...
    def clear(self) -> None: ...
    def has(self, value: Vector2) -> bool: ...
    def reverse(self) -> None: ...
    def slice(self, begin: int, end: int = 2147483647) -> PackedVector2Array: ...
    def to_byte_array(self) -> PackedByteArray: ...
    def sort(self) -> None: ...
    def bsearch(self, value: Vector2, before: bool = True) -> int: ...
    def duplicate(self) -> PackedVector2Array: ...
    def find(self, value: Vector2, from_: int = 0) -> int: ...
    def rfind(self, value: Vector2, from_: int = -1) -> int: ...
    def count(self, value: Vector2) -> int: ...


class PackedVector3Array:
    def __init__(self): ...
    def __init__(self, from_: PackedVector3Array): ...
    def __init__(self, from_: GDArray): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def set(self, index: int, value: Vector3) -> None: ...
    def push_back(self, value: Vector3) -> bool: ...
    def append(self, value: Vector3) -> bool: ...
    def append_array(self, array: PackedVector3Array) -> None: ...
    def remove_at(self, index: int) -> None: ...
    def insert(self, at_index: int, value: Vector3) -> int: ...
    def fill(self, value: Vector3) -> None: ...
    def resize(self, new_size: int) -> int: ...
    def clear(self) -> None: ...
    def has(self, value: Vector3) -> bool: ...
    def reverse(self) -> None: ...
    def slice(self, begin: int, end: int = 2147483647) -> PackedVector3Array: ...
    def to_byte_array(self) -> PackedByteArray: ...
    def sort(self) -> None: ...
    def bsearch(self, value: Vector3, before: bool = True) -> int: ...
    def duplicate(self) -> PackedVector3Array: ...
    def find(self, value: Vector3, from_: int = 0) -> int: ...
    def rfind(self, value: Vector3, from_: int = -1) -> int: ...
    def count(self, value: Vector3) -> int: ...


class PackedColorArray:
    def __init__(self): ...
    def __init__(self, from_: PackedColorArray): ...
    def __init__(self, from_: GDArray): ...

    # Methods
    def size(self) -> int: ...
    def is_empty(self) -> bool: ...
    def set(self, index: int, value: Color) -> None: ...
    def push_back(self, value: Color) -> bool: ...
    def append(self, value: Color) -> bool: ...
    def append_array(self, array: PackedColorArray) -> None: ...
    def remove_at(self, index: int) -> None: ...
    def insert(self, at_index: int, value: Color) -> int: ...
    def fill(self, value: Color) -> None: ...
    def resize(self, new_size: int) -> int: ...
    def clear(self) -> None: ...
    def has(self, value: Color) -> bool: ...
    def reverse(self) -> None: ...
    def slice(self, begin: int, end: int = 2147483647) -> PackedColorArray: ...
    def to_byte_array(self) -> PackedByteArray: ...
    def sort(self) -> None: ...
    def bsearch(self, value: Color, before: bool = True) -> int: ...
    def duplicate(self) -> PackedColorArray: ...
    def find(self, value: Color, from_: int = 0) -> int: ...
    def rfind(self, value: Color, from_: int = -1) -> int: ...
    def count(self, value: Color) -> int: ...
